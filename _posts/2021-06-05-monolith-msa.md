---
layout: single
title : "Monolith & MSA"
category: "msa"
---

> edX에서 쿠버네티스를 공부하면서 알게 된 내용을 정리하고 공유합니다.

MSA에 대해 알기 위해서는 기존 Monolith Architecture가 무엇인지, 단점은 무엇이었는지를 알아야 한다.

## Monolith

1. 클라우드 환경에 적합하지 않다.
2. 기능들이 퇴적물처럼 쌓여 있다.
3. 중복되는 기능들이 수천줄의 코드로 표현되어 있다.
4. 현대적이지 않은 하나의 언어로 구성이 되어 있다.
5. 구시대의 아키텍쳐 패턴과 규칙을들 지키고 있다.

위와 같은 특징을 가지는 Monolith은 큰 바위와 같다. 그 바위는 옮기기도 그 안을 수정하기도 쉽지 않다. 새로운 기능을 추가할 때 기존 코드와 상호작호하면서 복잡성은 기하급수적으로 올라가고, 로딩/컬파일링/빌드 시간이 매번 새로운 기능을 추가할 때마다 증가한다. 그리고 하나의 서버에서 돌아간다.

하나의 어플리케이션으로 하나의 서버에서 돌아야 하기 때문에 높은 메모리, 비싼 CPU가 필요하게 되며, 이런 컴퓨터는 비싸기 때문에 하드웨어와 경제적인 측면에서도 좋지 못하다.

또 확장(Scaling)도 어려운데, 병목이 생기는 내부 단일 기능에 대해 확장이 불가능하다. 전에 어플리케이션을 여러 서버에 두고 앞에 로드밸런서를 붙여 확장이 가능하지만 이 것 역시 비싼 서버를 여러대 두어야 하고, 확장이 불필요한 부분까지 확장이 들어가야 하기 때문에 좋지 않은 방법이다.

기능을 업데이트할 때도 비교적 긴 다운타임을 가져갈 수 밖에 없다.



## MSA

Micro Service Architecture는 매우 큰 바위와 다르게 수많은 조약돌과 같다고 할 수 있다. 하나의 큰 어플리케이션으로부터 분리 가능한 기능들을 각 분산된 모듈로 쪼개어 나누고 각자 구동하며 서로 가벼운 방식으로 소통이 가능하도록 하는 구조이다. 각 모듈들은 하나로 합쳐지만 기존 Monolith와 같은 기능을 제공한다. 

MSA를 조약돌과 같다고 했는데 조약돌은 느슨하게 결합되어 있고 각자의 특정한 비지니스 기능을 수행하는 마이크로서비스를 의미한다. MSA는 조약돌과 같이 또 바위와는 반대로 쉽게 고르고 옮기고 그룹화할 수 있다. 

마이크로 서비스는 적은 리소스를 가진 여러 서버에 베포가 될 수 있다. 그리고 복잡한 어플리케이션가 작은 독립 프로세스로 구성되는 Event Driven Arthitecture, Service Oriented Architecture와 결을 같이 한다. 

각 마이크로서비스는 각자 요구사항에 맞는 현대 프로그래밍 언어를 사용해서 개발된다. 

MSA의 분산화된 특성이 아키텍쳐에 복잡성을 더하기는 하지만, 이를 뛰어넘는 확장성이라는 장점을 얻을 수 있다. 전체 어플리케이션이 수요에 따라 모듈화될수록 각 마이크로서비스는 개별적으로 확장이 가능하다. 

매끄러운 업그레이드도 MSA의 장점이다. 각 마이크로 서비스가 순차적으로 업데이트 되기 때문에 사용자 입장에서 다운타임이 거의 없게 된다.

비지니스 입장에서 보면 새로운 기능을 더 빨리 개발할 수 있고 각 기능을 개발하는 여러 팀으로 나누어 운영할 수 있게 된다.



## Monolith to MSA

어떤 기업들은 자신의 Monolith 어플리케이션을 MSA 형태로 운영해보려고 하지만 잘 동작하지 않습니다. 다른 접근이 필요한데 기존 Monolith 구조의 어플리케이션을 MSA 형태로 변화시켜 나가는 것입니다. 그리고 여기에는 빅뱅 접근 방식, 점진적 개선 방식이 존재합니다.

빅뱅 접근 방식은 현재 사업에 영향이 있더라도 추가직인 기능 개발을 멈추고 전체 어플리케이션을 단번에 MSA로 변경하는 것입니다. 

점진적 개선 방식은 기존의 서비스는 그대로 두고 새롭게 추가되는 기능들에 대해 MSA 구조를 가져가도록 하는 방법입니다. 해당 기능들을 담당하는 마이크로 서비스는 기존 Monolith 어플리케이션과 API로 상호작용 합니다. 그리고 추가적으로 기존에 있던 Monolith 어플리케이션도 점진적으로 하나의 기능씩 MSA 형태로 변경해 갑니다. 이러한 방식은 점진적으로 기존 어플리케이션 기능들을 클라우드로 통합할 수 있도록 해 줍니다.

MSA로 전환하기 위한 접근 방식을 고른 후에는 

1. 어떤 비지니스 컴포넌트를 떼어내어 마이크로 서비스로 바꿀 것인가 
2. 어떻게 데이터 복잡성을 어플리케이션 로직으로부터 분리하기 위해 DB를 어플리케이션으로부터 분리할 것인가
3. 어떻게 새로운 마이크로서비스를 테스트할 것인가

와 이외에도 수많은 의사결정 과정을 직면하게 됩니다.

이 과정을 통해 기존 Monolith 어플리케이션은 새로운 프로그래밍 언어를 사용하고 현대 아키텍쳐 패턴을 사용하면서 클라우드 네이티브 어플리케이션으로 변화됩니다.

그런데 모든 Monolith 어플리케이션이 MSA로 변화될 수 있는 것은 아닙니다. 고려해야 할 사항들이 있는데, 코볼이나 어셈블리로 쓰여진 어플리케이션이 있다면 아예 처음부터 다시 어플리케이션을 개발하는 것이 더 나을 것입니다. 잘못 설계된 아키텍쳐는 마이크로 서비스와 컨테이너를 위해 설계된 현대 아키텍쳐 패턴을 따라 다시 디자인 되어야 합니다. 그리고 DB와 비지니스 로직이 강하게 결합되어 있는 어플리케이션도 MSA로 변환하기에 적합하지 않을 확률이 높습니다.

그리고 Monolith 어플리케이션이 MSA로 리팩토링 되면 모든 마이크로서비스가 살아있는지 확인할 수 있는 매커니즘과 도구를 찾는 것입니다. 기존에는 하나의 어플리케이션만 확인하면 되었는데, 이제는 나뉘어진 모듈들을 모두 확인해주어야 합니다.

그리고 어떤 방식으로 각 마이크로서비스를 구동할 것인지도 도전입니다. 만약 하나의 서버, 운영체제에서 모든 마이크로 서비스를 돌린다면 아마도 각 서비스들끼리 충도할 가능성이 높습니다.  하지만 그렇다고 하나의 마이크로 서비스를 하나의 서버에 돌리는 것도 우선 경제적인 측면에서 좋은 해결책은 아닙니다. 하나의 서버에서 어플리케이션을 통한 자원 소모보다 운영체제를 통한 자원 소모가 더 클 확률이 있습니다.

이를 해결하기 위해서 캡슐화된 경량 실행 환경을 제공하는 어플리케이션 컨테이너가 좋은 대안이 될 수 있습니다. 컨테이너는 항상 일관된 개발, 테스트 환경을 제공하며 하나의 서버에서 서로 독립적으로 여러개의 어플리케이션을 실행할 수 있도록 해줍니다. 또 컨테이너를 사용하면 개별 모듈을 유연하게 확장할 수 있고 자동화 툴의 도움을 많이 받을 수 있습니다. 

